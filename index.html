<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Блог компании Яндекс.</title>
</head>
<body>
    <div id="header">
        <h1>
            ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ
        </h1>
        <div>
            Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
            какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br>
            тормозит. Мы регулярно добавляем в <a href="https://mail.yandex.com/">Яндекс.Почту</a>
            новую функциональность,<br>
            иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
            и новая логика. Всё это напрямую влияет на скорость работы интерфейса.
        </div>
    </div>
    <main>
        <article id="whatWeSearch">
            <h2>Что мы измеряем</h2>
            <p>Этапы первой загрузки:</p>
            <ul>
                <li>подготовка;</li>
                <li>загрузка статики (HTTP-запрос и парсинг);</li>
                <li>исполнение модулей;</li>
                <li>инициализация базовых объектов;</li>
                <li>отрисовка.</li>
            </ul>
            <p>Этапы отрисовки любой страницы:</p>
            <ul>
                <li>подготовка к запросу на сервер;</li>
                <li>запрос данных с сервера;</li>
                <li>шаблонизация;</li>
                <li>обновление <abbr title="Document Object Model">DOM.</abbr></li>
            </ul>
            <div>
                - <q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы<br>
                - <q>Что же дальше?</q> - вопрошаете вы<br>
                - <q>А давай построим график!</q> - отвечаем мы<br>
                - <q>А что будем считать?</q> - уточняете вы<br>
            </div>
            <p>
                Как вы знаете, <em>медиана</em> – это серединное, а не среднее значение в выборке.<br>
                Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20,
                &nbsp;то <em>медиана</em> – 3, а <em>среднее</em> – 6,5.<br>
                В общем случае <em>медиана</em> отлично показывает, сколько грузится средний пользователь.
            </p>
            <div>
                В случае ускорения или замедления <em>медиана</em> конечно, изменится. Но она не может<br>
                рассказать, сколько пользователей ускорилось, а сколько замедлилось.
            </div>
            <p>
                <abbr title="Application Performance Index"><dfn>APDEX</dfn></abbr>
                &nbsp;– метрика, которая сразу говорит: хорошо или плохо. Метрика<br>
                работает очень просто. Мы выбираем временной интервал <samp>[0; t]</samp>
                , такой, что если<br>
                время показа страницы попало в него, то пользователь счастлив. Берем еще один<br>
                интервал, <samp>(t; 4t]</samp>
                &nbsp;(в четыре раза больше первого), и считаем, что если страница<br>
                показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
                но уже не настолько счастлив. И применяем формулу:
            </p>
            <p>
                (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
                Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
                хорошо или плохо работает почта.
            </p>
        </article>
        <article id="howWeSearch">
            <h2>Как мы измеряем</h2>
            <p>
                Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br>
                причину замедления: медленнее стал отвечать сервер либо слишком долго<br>
                выполняется JavaScript. Выглядит это примерно так:
            </p>
            <code>
                this.timings['look-ma-im-start'] = Date.now();<br>
                this.timings['look-ma-finish'] = Date.now();<br>
            </code>
            <p>
                C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при<br>
                отправке рассчитываются. На этапах разница между <code>“end”</code> и <code>“start”</code>
                &nbsp;не считается,<br>а все вычисления производятся в конце:
            </p>
            <code>
                var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
            </code>
            <p>И на сервер прилетают подобные записи:</p>
            <code>serverResponse=50&amp;domUpdate=60</code>
        </article>
        <article id="howWeBoost">
            <h2>Как мы ускоряем</h2>
            <p>Чтобы снизить время загрузки почты при выходе новых версий,<br>мы уже делаем следующее:</p>
            <ul>
                <li>включаем gzip;</li>
                <li>выставляем заголовки кэширования;</li>
                <li>фризим CSS, JS, шаблоны и картинки;</li>
                <li>используем <abbr title="Content delivery network">CDN</abbr>;</li>
            </ul>
            <p>
                Мы подумали: <q>
                    А что если хранить где-то старую версию файлов, а при выходе новой<br>
                    передавать только <code>diff</code> между ней и той, которая сохранена у пользователя?
                </q>
                <br>
                В браузере же останется просто наложить патч на клиенте.
            </p>
            <p>
                На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,<br>
                RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они<br>
                не получили должного распространения в браузерах и на серверах.
            </p>
            <p>
                Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br>
                начали искать реализации <code>diff</code> на JS. На популярных хостингах кода нашли<br>
                библиотеки:<br>
                &mdash; VCDiff<br>
                &mdash; google-diff-patch-match<br>
            </p>
            <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
            <table title="browsersDiff">
                <thead>
                    <tr>
                        <td>Библиотека</td>
                        <td>IE 9</td>
                        <td>Opera 12</td>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>vcdiff</td>
                        <td>8</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td>google diff</td>
                        <td>1363</td>
                        <td>76</td>
                    </tr>
                </tbody>
            </table>
            <p>
                После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br>
                где и как хранить статику на клиенте.
            </p>
            <p>Формат файла с патчами для проекта выглядит так:</p>
            <pre class="json">
[
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    },
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    }
]
            </pre>
            <div>
                То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У<br>
                каждого объекта есть три свойства. <var>k</var> — названия ключа в localStorage для этого<br>
                ресурса. <var>p</var> — патч для ресурса, который сгенерировал vcdiff.
                &nbsp;<var>s</var> — чексумма для<br>
                ресурса актуальной версии, чтобы потом можно было проверить правильность<br>
                наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.<br>
            </div>
            <p>
                <dfn>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</dfn><br>
                — итерационный метод численной оптимизации, предназначенный для<br>
                нахождения локального максимума/минимума нелинейного функционала<br>
                без ограничений.
            </p>
            <div id="algoritm">
                дано &epsilon;, <var>x<sub>0</sub></var><br>
                инициализировать <var>H<sub>0</sub></var><br>
                <var>k</var> = 0<br>
                <strong>while</strong>||&nabla;&fnof;<sub><var>k</var></sub>|| &gt; &epsilon;<br>
                &nbsp;&nbsp;найти направление <var>p<sub>k</sub></var> = <var>-C<sub>k</sub></var>
                &nabla;&fnof;<var><sub>k</sub></var><br>
                &nbsp;&nbsp;вычислить <var>x<sub>k+1</sub> = x<sub>k</sub> +
                &alpha;<sub>k</sub>p<sub>k</sub>, &alpha;<sub>k</sub>
                </var> удовлетворяет условиям Вольфе<br>
                &nbsp;&nbsp;обозначить <var>s<sub>k</sub> = x<sub>k+1</sub> - x<sub>k</sub></var>
                и <var>y<sub>k</sub></var> = &nabla;&fnof;<var><sub>k+1</sub> - &nabla;</var>&fnof;<br>
                &nbsp;&nbsp;вычислить <var>C<sub>k+1</sub></var><br>
                &nbsp;&nbsp;<var>k = k + 1</var><br>
                <strong>end</strong>
            </div>
            <p>
                Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:<br>
                <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC16/32</a>
                &nbsp;- алгоритм нахождения контрольной суммы,
                &nbsp;предназначенный для проверки<br>целостности данных<br>
                <a href="https://en.wikipedia.org/wiki/MD5">md5</a> - 128-битный алгоритм хеширования.
                &nbsp;Предназначен для создания «отпечатков»<br>
                или дайджестов сообщения произвольной длины и последующей проверки<br>их подлинности.<br>
            </p>
            <p>Потому что он быстрый, компактный и легок в реализации.</p>
        </article>
        <article id="summary">
            <h2>Итог</h2>
            <p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>
            <table>
                <thead>
                    <tr>
                        <td>Релиз</td>
                        <td>С патчем</td>
                        <td>Без патча</td>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>7.7.20</td>
                        <td>397</td>
                        <td>174 549</td>
                    </tr>
                    <tr>
                        <td>7.7.21</td>
                        <td>383</td>
                        <td>53 995</td>
                    </tr>
                    <tr>
                        <td>7.7.22</td>
                        <td>483</td>
                        <td>3 995</td>
                    </tr>
                </tbody>
            </table>
        </article>
        <div id="info">
            <address>
                Автор: <a href="">@doochik</a><br>
                С++ разработик<br>
                Электронная почта:
                &nbsp;(<a href="mailto:doochik@yandex-team.ru">doochik@yandex-team.ru</a>)<br>
                Компания: Яндекс<br>
            </address>
        </div>
        <div id="comments">
            <h4>Комментарии (3):</h4>
            <div class="comment">
                <header class="author">
                    &mdash;Mogaika
                    (<a href="mailto:mogaika@yandex-team.ru">mogaika@yandex-team.ru</a>)
                    30 ноября 2014 в <time>17:05</time>
                </header>
                <div class="message">
                    А можете привести сравнение, на сколько быстрее грузится lite версия?
                </div>
                <br>
            </div>
            <div class="comment">
                <header class="author">
                    &mdash;JIguse
                    (<a href="mailto:mrawesome@yandex.ru">mrawesome@yandex.ru</a>)
                    29 ноября 2014 в <time>21:30</time>
                </header>
                <div class="message">
                    Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>
                    подробностями о внутренней работе сервисов.
                </div>
                <br>
            </div>
            <div class="comment">
                <header class="author">
                    &mdash;Brister
                    (<a href="mailto:brist89@yandex-team.ru">brist89@yandex-team.ru</a>)
                    24 ноября 2014 в <time>13:13</time>
                </header>
                <div class="message">
                    (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
                    Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
                    хорошо или плохо работает почта.<br>
                    наверное все-таки от 0.5 до 1
                </div>
                <br>
            </div>
            <div class="comment">
                <header class="author">
                    &mdash;alexeimois
                    (<a href="mailto:test@yandex.ru">test@yandex.ru</a>)
                    22 ноября 2014 в <time>17:35</time>
                </header>
                <div class="message">
                    Мы измеряем скорость загрузки с помощью Яндекс.Метрики:<br>
                    help.yandex.ru/metrika/reports/monitoring_timing.xml
                </div>
                <br>
            </div>
        </div>
    </main>
    <footer>
        <hr>&copy; Яндекс,
        &nbsp;<a href="mailto:help@yandex.ru">help@yandex.ru</a>,
        &nbsp;Хохрякова, 10
    </footer>
</body>
</html>
